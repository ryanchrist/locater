---
title: "Simple GWAS Example"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Simple GWAS Example}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, eval = TRUE}
set.seed(7)

library(locater)
library(kalis)

# Load simulated haplotypes and recombination map
CacheHaplotypes(SmallHaps)
map <- SmallMap


# Simulate Phenotypes
n <- N()/2 # number of samples
m <- 20 # number of phenotypes

y <- matrix(rnorm(n*m),n,m)
g <- QueryCache(c(204,205,207,210)) # c(204,205,207) are indices of causal loci
y[,1] <- y[,1] + colSums((g[,seq(1,N(),2)] + g[,seq(2,N(),2)])*c(150,10,30,100)#c(150,8,20)
                         /rowSums(g))
A <- matrix(1,n,1) # background covariate matrix is just an index here


# Specify Locater screening parameters 
pars <- Parameters(CalcRho(diff(map),s = 0.0001),mu = 1e-16) # specify HMM parameters

# Specify a list of optional arguments to control exactly how locater tests each position. If more than one combination of testing parameters is desired, a data.frame with multiple rows can be given and locater will efficiently evaluate all testing options.
test.opts <- data.frame("max.k" = 128,
                        "sw.thresh" = 6,
                        "eig.thresh" = 6.5,
                        "calc.obs.T" = TRUE)


# Determine target loci based on SMT
smt.res <- TestCachedMarkers(y, A = A)
target.loci <- FindTargetVars(map, min.cM = 0.1, initial.targets = smt.res, smt.thresh = 3)

set.seed(53)
res <- TestLoci(y, pars, target.loci = target.loci, test.opts = test.opts, verbose = TRUE)
# 
# set.seed(89)
# res2 <- TestLoci(y, pars, target.loci = target.loci, test.opts = test.opts, verbose = TRUE)
# 
# plot(res$rd,res2$rd);abline(0,1)
# t.test(qnorm(10^-res$rd),qnorm(10^-res2$rd))
# 
# plot(res$tot,res2$tot);abline(0,1)
# t.test(qnorm(10^-res$tot),qnorm(10^-res2$tot))

# sw_approx_qform <- res[phenotype==1,qform]
# plot(sw_approx_qform,res[phenotype==1,qform]);abline(0,1)


smt.p1 <- smt.res[,1]
res.p1 <- res[phenotype==1,c("locus.idx","tot")]

COLORS <- palette.colors(3)
plot(0,0, type = "n", 
     ylim=range(pretty(c(0,max(c(smt.p1,res.p1$tot),na.rm=T)))),
     xlim = range(pretty(map)),
     las=1,bty="n",
     ylab = "-log10 p-value", xlab = "cM position")
points(map,smt.p1,col=COLORS[1],pch=20)
points(map[res.p1$locus.idx],res.p1$tot,col=COLORS[2],pch=20)
legend("topleft",legend = c("SMT","LOCATER"),
       fill = COLORS, bty = "n")
# Specify a screening threshold: we will revisit variants which have an approximate -log10 p-value greater than screening.thresh
# screening.thresh <- 6
# 
# # Select set of target loci for follow up
# new.target.loci <- as.list(1:max(approx.res$test.config))
# for(i in 1:length(new.target.loci)){
#   new.target.loci[[i]] <- as.integer(
#     approx.res[test.config==i,locus.idx[which.thresh.middle(tot,screening.thresh)],phenotype]$V1)}
# new.target.loci <- sort(unique(unlist(new.target.loci)))

# Run TestLoci with sw.approx = FALSE to revisit and exactly evaluate candidate loci
# exact.res <- TestLoci(y, pars, target.loci = new.target.loci, sw.approx = FALSE, test.opts = test.opts, verbose = TRUE)

# Make Manhattan Plot
# smt.p1 <- smt.res[,1]
# approx.p1 <- approx.res[phenotype==1 & test.config == 2,c("locus.idx","tot")]
# exact.p1 <- exact.res[phenotype==1 & test.config == 2,c("locus.idx","tot")]
# 
# COLORS <- palette.colors(3)
# plot(0,0, type = "n", 
#      ylim=range(pretty(c(0,max(c(smt.p1,approx.p1$tot,exact.p1$tot),na.rm=T)))),
#      xlim = range(map),
#      las=1,bty="n",
#      ylab = "-log10 p-value", xlab = "cM position")
# points(map,smt.p1,col=COLORS[1],pch=20)
# points(map[approx.p1$locus.idx],approx.p1$tot,col=COLORS[2],pch=20)
# points(map[exact.p1$locus.idx],exact.p1$tot,col=COLORS[3],pch=20)
# legend("topleft",legend = c("SMT","Approx Locater","Exact Locater"),
#        fill = COLORS, bty = "n")


```
